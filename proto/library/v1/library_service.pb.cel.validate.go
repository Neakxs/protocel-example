// Code generated by protoc-gen-go-cel-validate. DO NOT EDIT.
// versions:
//  protoc-gen-go-cel-validate	v0.1.0
//  protoc						v3.21.9
// source: proto/library/v1/library_service.proto

package v1

import (
	context "context"
	validate "github.com/Neakxs/protocel/validate"
	cel "github.com/google/cel-go/cel"
	proto "google.golang.org/protobuf/proto"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	sync "sync"
)

var _File_proto_library_v1_library_service_proto_rawValidateOptions = []byte{}

var (
	_File_proto_library_v1_library_service_proto_CreateAuthorRequest_celValidateMap     map[string]cel.Program = nil
	_File_proto_library_v1_library_service_proto_CreateAuthorRequest_celValidateMapOnce sync.Once
)

func (m *CreateAuthorRequest) Validate(ctx context.Context) error {
	return m.ValidateWithMask(ctx, &fieldmaskpb.FieldMask{
		Paths: []string{"*"},
	})
}

func (m *CreateAuthorRequest) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	_File_proto_library_v1_library_service_proto_CreateAuthorRequest_celValidateMapOnce.Do(func() {
		cfg := &validate.ValidateOptions{}
		if err := proto.Unmarshal(_File_proto_library_v1_library_service_proto_rawValidateOptions, cfg); err != nil {
			return
		}
		tmp := map[string]cel.Program{}
		for k, v := range map[string]struct {
			expr string
			req  proto.Message
		}{
			"author": {expr: `author.validate()`, req: m},
		} {
			if pgr, err := validate.BuildValidateProgram(v.expr, v.req, cfg); err != nil {
				return
			} else {
				tmp[k] = pgr
			}
		}
		_File_proto_library_v1_library_service_proto_CreateAuthorRequest_celValidateMap = tmp
	})
	return validate.ValidateWithMask(ctx, m, fm, _File_proto_library_v1_library_service_proto_CreateAuthorRequest_celValidateMap)
}

var (
	_File_proto_library_v1_library_service_proto_ListAuthorsRequest_celValidateMap     map[string]cel.Program = nil
	_File_proto_library_v1_library_service_proto_ListAuthorsRequest_celValidateMapOnce sync.Once
)

func (m *ListAuthorsRequest) Validate(ctx context.Context) error {
	return m.ValidateWithMask(ctx, &fieldmaskpb.FieldMask{
		Paths: []string{"*"},
	})
}

func (m *ListAuthorsRequest) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	_File_proto_library_v1_library_service_proto_ListAuthorsRequest_celValidateMapOnce.Do(func() {
		cfg := &validate.ValidateOptions{}
		if err := proto.Unmarshal(_File_proto_library_v1_library_service_proto_rawValidateOptions, cfg); err != nil {
			return
		}
		tmp := map[string]cel.Program{}
		for k, v := range map[string]struct {
			expr string
			req  proto.Message
		}{
			"page_size": {expr: `page_size >= 0`, req: m},
		} {
			if pgr, err := validate.BuildValidateProgram(v.expr, v.req, cfg); err != nil {
				return
			} else {
				tmp[k] = pgr
			}
		}
		_File_proto_library_v1_library_service_proto_ListAuthorsRequest_celValidateMap = tmp
	})
	return validate.ValidateWithMask(ctx, m, fm, _File_proto_library_v1_library_service_proto_ListAuthorsRequest_celValidateMap)
}

func (m *ListAuthorsResponse) Validate(ctx context.Context) error {
	return nil
}

func (m *ListAuthorsResponse) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	return nil
}

var (
	_File_proto_library_v1_library_service_proto_DeleteAuthorRequest_celValidateMap     map[string]cel.Program = nil
	_File_proto_library_v1_library_service_proto_DeleteAuthorRequest_celValidateMapOnce sync.Once
)

func (m *DeleteAuthorRequest) Validate(ctx context.Context) error {
	return m.ValidateWithMask(ctx, &fieldmaskpb.FieldMask{
		Paths: []string{"*"},
	})
}

func (m *DeleteAuthorRequest) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	_File_proto_library_v1_library_service_proto_DeleteAuthorRequest_celValidateMapOnce.Do(func() {
		cfg := &validate.ValidateOptions{}
		if err := proto.Unmarshal(_File_proto_library_v1_library_service_proto_rawValidateOptions, cfg); err != nil {
			return
		}
		tmp := map[string]cel.Program{}
		for k, v := range map[string]struct {
			expr string
			req  proto.Message
		}{
			"name": {expr: `name.matches("^(authors/[\\w-\\.]+)$")`, req: m},
		} {
			if pgr, err := validate.BuildValidateProgram(v.expr, v.req, cfg); err != nil {
				return
			} else {
				tmp[k] = pgr
			}
		}
		_File_proto_library_v1_library_service_proto_DeleteAuthorRequest_celValidateMap = tmp
	})
	return validate.ValidateWithMask(ctx, m, fm, _File_proto_library_v1_library_service_proto_DeleteAuthorRequest_celValidateMap)
}

var (
	_File_proto_library_v1_library_service_proto_CreateBookRequest_celValidateMap     map[string]cel.Program = nil
	_File_proto_library_v1_library_service_proto_CreateBookRequest_celValidateMapOnce sync.Once
)

func (m *CreateBookRequest) Validate(ctx context.Context) error {
	return m.ValidateWithMask(ctx, &fieldmaskpb.FieldMask{
		Paths: []string{"*"},
	})
}

func (m *CreateBookRequest) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	_File_proto_library_v1_library_service_proto_CreateBookRequest_celValidateMapOnce.Do(func() {
		cfg := &validate.ValidateOptions{}
		if err := proto.Unmarshal(_File_proto_library_v1_library_service_proto_rawValidateOptions, cfg); err != nil {
			return
		}
		tmp := map[string]cel.Program{}
		for k, v := range map[string]struct {
			expr string
			req  proto.Message
		}{
			"parent": {expr: `parent.matches("^(authors/[\\w-\\.]+)$")`, req: m},
			"book":   {expr: `book.validate()`, req: m},
		} {
			if pgr, err := validate.BuildValidateProgram(v.expr, v.req, cfg); err != nil {
				return
			} else {
				tmp[k] = pgr
			}
		}
		_File_proto_library_v1_library_service_proto_CreateBookRequest_celValidateMap = tmp
	})
	return validate.ValidateWithMask(ctx, m, fm, _File_proto_library_v1_library_service_proto_CreateBookRequest_celValidateMap)
}

var (
	_File_proto_library_v1_library_service_proto_ListBooksRequest_celValidateMap     map[string]cel.Program = nil
	_File_proto_library_v1_library_service_proto_ListBooksRequest_celValidateMapOnce sync.Once
)

func (m *ListBooksRequest) Validate(ctx context.Context) error {
	return m.ValidateWithMask(ctx, &fieldmaskpb.FieldMask{
		Paths: []string{"*"},
	})
}

func (m *ListBooksRequest) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	_File_proto_library_v1_library_service_proto_ListBooksRequest_celValidateMapOnce.Do(func() {
		cfg := &validate.ValidateOptions{}
		if err := proto.Unmarshal(_File_proto_library_v1_library_service_proto_rawValidateOptions, cfg); err != nil {
			return
		}
		tmp := map[string]cel.Program{}
		for k, v := range map[string]struct {
			expr string
			req  proto.Message
		}{
			"parent":    {expr: `parent.matches("^(authors/[\\w-\\.]+)$")`, req: m},
			"page_size": {expr: `page_size >= 0`, req: m},
		} {
			if pgr, err := validate.BuildValidateProgram(v.expr, v.req, cfg); err != nil {
				return
			} else {
				tmp[k] = pgr
			}
		}
		_File_proto_library_v1_library_service_proto_ListBooksRequest_celValidateMap = tmp
	})
	return validate.ValidateWithMask(ctx, m, fm, _File_proto_library_v1_library_service_proto_ListBooksRequest_celValidateMap)
}

func (m *ListBooksResponse) Validate(ctx context.Context) error {
	return nil
}

func (m *ListBooksResponse) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	return nil
}

var (
	_File_proto_library_v1_library_service_proto_DeleteBookRequest_celValidateMap     map[string]cel.Program = nil
	_File_proto_library_v1_library_service_proto_DeleteBookRequest_celValidateMapOnce sync.Once
)

func (m *DeleteBookRequest) Validate(ctx context.Context) error {
	return m.ValidateWithMask(ctx, &fieldmaskpb.FieldMask{
		Paths: []string{"*"},
	})
}

func (m *DeleteBookRequest) ValidateWithMask(ctx context.Context, fm *fieldmaskpb.FieldMask) error {
	_File_proto_library_v1_library_service_proto_DeleteBookRequest_celValidateMapOnce.Do(func() {
		cfg := &validate.ValidateOptions{}
		if err := proto.Unmarshal(_File_proto_library_v1_library_service_proto_rawValidateOptions, cfg); err != nil {
			return
		}
		tmp := map[string]cel.Program{}
		for k, v := range map[string]struct {
			expr string
			req  proto.Message
		}{
			"name": {expr: `name.matches("^(authors/[\\w-\\.]+/books/[\\w-\\.]+)$")`, req: m},
		} {
			if pgr, err := validate.BuildValidateProgram(v.expr, v.req, cfg); err != nil {
				return
			} else {
				tmp[k] = pgr
			}
		}
		_File_proto_library_v1_library_service_proto_DeleteBookRequest_celValidateMap = tmp
	})
	return validate.ValidateWithMask(ctx, m, fm, _File_proto_library_v1_library_service_proto_DeleteBookRequest_celValidateMap)
}
